<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>TLS 1.3 Handshake Protocol</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="style.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">TLS 1.3 Handshake Protocol</h1>
</header>
<head>
<title>
TLS 1.3 Handshake
</title>
<p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"
        integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous"></p>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"
        integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg"
        crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>
<h2 id="dicp---part-1">DICP - Part 1</h2>
<h3 id="flights-and-message-encryption">Flights and Message
Encryption</h3>
<p>A TLS flight consists of one or more messages sent in a sequence
without waiting for response from the receiving endpoint. In a typical
session, for example, we can relate messages and flights so:</p>
<pre><code>    Flight     Message               Sender
   -----------------------------------------
      1      Client Hello            Client
      2      Server Hello            Server
      3      Change Cipher Spec      Server
      4      Encrypted Extensions    Server
             Certificate
             Certificate Verify
             Server Finished
      5      Client Finished         Client
</code></pre>
<p>A TLS server normally sends <code>Encrypted Extensions</code>,
<code>Certificate</code>, <code>Certificate Verify</code>, and
<code>Server Finished</code> messages in one flight.</p>
<p>Most servers encrypt individual plaintext messages and send each
ciphertext in turn. The sequence of these ciphertext records represents
a flight. A few servers, on the contrary, encrypt the entire sequence of
plaintext messages into one ciphertext block, and send the ciphertext in
one flight. In our tests, we have found “x.com:443” and
“www.google.com:443” employ the latter method for .</p>
<h3 id="background">Background</h3>
<p>Virtually every online financial transaction is protected by
Transport Layer Security (TLS). Open Banking standards across the globe
make TLS version 1.2 or above mandatory for participating entities. TLS
is undoubtedly one of the most widely deployed internet security
protocol. More recent messaging protocol, MLS (RFC 9420, section-16.1),
recommends all MLS messages to be transmitted over TLS 1.3.</p>
<h3 id="aead">AEAD</h3>
<p>Authenticated Encryption with Associated Data (AEAD) [Rog02] has
emerged as being the right cryptographic tool for building secure
channels. AEAD provides both confidentiality and integrity guarantees
for data.</p>
<h3 id="stateful-aead">Stateful AEAD</h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc5116">Requirements
on AEAD Algorithm Specifications</a></p>
<p>An Authenticated Encryption algorithm MAY incorporate internal state
information that is maintained between invocations of the encrypt
operation, e.g., to allow for the construction of distinct values that
are used as internal nonces by the algorithm. An AEAD algorithm of this
sort is called stateful. This method could be used by an algorithm to
provide good security even when the application inputs zero-length
nonces.</p>
<h3 id="aeads-and-secure-channel">AEADs and Secure Channel</h3>
<p>In <a href="https://eprint.iacr.org/2017/1191.pdf">Data Is a Stream:
Security of Stream-Based Channels</a>, Marc Fischlin et.al., note that
while AEAD provides both confidentiality and integrity guarantees for
data, on its own, AEAD does not constitute a secure channel. For
example, in most practical situations, a secure channel should provide
more than simple encryption of messages, but also guarantee detection of
(and possibly recovery from) out-of-order delivery and replays of
messages.</p>
<h3 id="the-state-machine">The State Machine</h3>
<p>In part 1 we will consider the implementation of a TLS 1.3 client
program. We call this version of the client program <em>tlsc</em>. In
TLS 1.3 parlance, <em>tlsc</em> implements 1-RTT handshake using ECDHE
key exchange mode without client authentication. This characterization
gives a specific structure to the interactions between <em>tlsc</em> and
a TLS 1.3 compliant server. To see the shape of the interaction, refer
to Figure 1 on page 11 of RFC 8446. We will also use the state machines
<code>A.1. Client</code> (page 120) and <code>A.2. Server</code> (page
121) in Appendix A.</p>
<pre><code>Client                              Server

&lt;Key Exchange&gt;
    ClientHello
        + key_share
        + signature_algorithms
                        --------&gt;
                                    &lt;Key Exchange&gt;
                                        ServerHello
                                            + key_share

                                    &lt;Server Params&gt;
                                        {EncryptedExtensions}

                                    &lt;Auth&gt;
                                        {Certificate}
                                        {CertificateVerify}
                                        {Finished}
                        &lt;--------

&lt;Auth&gt;
    {Finished}

&lt;App&gt;
[Application Data]    &lt;-------&gt;     [Application Data]</code></pre>
<p><code>Figure 1 - Shape of 1-RTT Handshake without Client Authentication.</code></p>
<p>While reading the diagram imagine that time progresses vertically
downward and interaction flows in the direction of arrows.</p>
<p>In presenting the diagram above, we have reused the notational
convention from RFC 8446 with one augmentation.</p>
<ol type="1">
<li><code>+</code> indicates important extensions sent in the
message.</li>
<li><code>{}</code> shows messages protected using keys derived from a
<code>[sender]_handshake_traffic_secret</code>.</li>
<li><code>[]</code> indicates messages protected using keys derived from
<code>[sender]_application_traffic_secrete_N</code>.</li>
<li><code>&lt;&gt;</code> names a phase or a sub-protocol. This is our
own notation; this is not from RFC 8446.</li>
</ol>
<p>Figure 1 shown above is a simplified version of Figure 1 from the
RFC. We leave out <em>pre-shared key (PSK)</em> mode, and authentication
messages, Certificate and CertificateVerify, on the client side.</p>
<p>In this document (<code>DICP - Part 1</code>), we will study the
technical aspects of implementing the interactions shown in Figure 1. We
will delve into the details of various cryptographic primitives used in
each step of the interaction. We will try to reason why TLS 1.3 chooses
to use cryptographic constructions in the fashion it does. We will also
try to clarify and elaborate aspects where the text in the RFC is either
cryptic or is not too helpful.</p>
<h3 id="the-handshake-protocol">The Handshake Protocol</h3>
<p>The handshake (sub)protocol is the most important part of TLS.
Undoubtedly, the designers spent significant effort in improving its
efficiency compared to TLS 1.2. Most of the security guarantees of TLS
is deined by the handshake protocol. Section 4 of RFC 8446 (about 54
pages of text) is entirely dedicated for describing the messages and
interactions constituting handshake protocol. Even the appendices in the
RFC discuss, at length, the security aspects of the handshake
protocol.</p>
<h3 id="key-exchange">Key Exchange</h3>
<p>Within the handshake protocol, <em>Key Exchange</em> is the first
phase. In Figure 1 above, this includes two messages:</p>
<ol type="1">
<li>ClientHello
<ul>
<li>the very first message of the protocol.</li>
<li>describes cryptographic primitives and algorithms the client is
prepared to use in this session.</li>
<li>includes one or more ephemeral public keys for elliptic-curve
Diffie-Hellman exchange.</li>
<li>includes a 32 byte random number indicating client’s session
freshness.</li>
</ul></li>
<li>ServerHello.
<ul>
<li>the last/final plaintext message of the handshake protocol.</li>
<li>indicates the cryptographic primitives and algorithms the server has
accepted.</li>
<li>includes server’s public key for elliptic-curve Diffie-Hellman
exchange.</li>
<li>includes a 32 byte random number indicating server’s session
freshness.</li>
</ul></li>
</ol>
<p>At the end of key exchange, the client and server establish a set of
shared secrets used for encrypting (protecting) messages that follow. In
addition, the client and server agree upon the cryptographic algorithms
(aka ciphersuite) which will be in force for the rest of the
session.</p>
<h3 id="key-exchange-phase">Key Exchange Phase</h3>
<p>Client sends <code>ClintHello</code> to the server:
<a id="xref-client-hello-spec"></a></p>
<p><span class="math display">\[
    {\begin{array}{llll}
    \llbracket &amp; &amp; &amp; \\
        &amp; server\_name &amp; {\larr} &amp;
{\rm\normalsize{SERVER\_NAME}} \\
        &amp; {{handshake\_context}}       &amp; {\larr} &amp;
client\_hello\_msg\\
        &amp; {{cipher\_suite\_ids}} &amp; {\larr} &amp; [{cid_{1}, ...,
cid_{j}}] \ \text{where} \ 1 \le j \le 5\\
        &amp; {{key\_shares}}    &amp; {\larr} &amp; [(ecg_1, (sk^c_1,
pk^c_1)), \\
        &amp;&amp;&amp;                         \ \, ..., \\
        &amp;&amp;&amp;                         \ \, (ecg_m, (sk^c_m,
pk^c_m))] \ \text{where} \ 1 \le m\\
        &amp; {{signature\_schemes}}    &amp; {\larr} &amp; {&lt;}s_1,
..., s_n{&gt;} {\hspace*{60mm}} \\
    \rrbracket &amp; &amp; &amp; \\
    \end{array}}
\]</span></p>
<p><strong>ClientHello</strong> <img
src="./images/client_hello_layout.jpg" alt="client_hello_layout" /></p>
<p>Server state after deriving its handshake secrets: <span
class="math display">\[
    {\begin{array}{llll}
    \llbracket &amp; &amp; &amp; \\
        &amp; {handshake\_context}       &amp; {\larr} &amp;
{\rm\normalsize{Concat}}(client\_hello\_msg, \\
        &amp;&amp;&amp;                                        \hspace*{12mm}
server\_hello\_msg)\\
        &amp; {cipher\_suite\_id} &amp; {\larr} &amp; cid \ \rm{where} \
cid \in \{{\rm\normalsize{CH}}.cid_{1}, ...,
{\rm\normalsize{CH}}.cid_{j}\}\\
        &amp; {cipher\_suite} &amp; {\larr} &amp;
{\rm\normalsize{CipherSuite}}(cid) \ \text{where} \ cid \in
\{{\rm\normalsize{CH}}.cid_{1}, ..., {\rm\normalsize{CH}}.cid_{j}\}\\
        &amp; {traffic\_secrets} &amp; {\larr} &amp; (hs, hts^s, hts^c)
\\
        &amp;&amp;&amp;                               {\rm{where}} \ hs
\ \ \, = {\rm\normalsize{HandshakeSecret(...)}} \\
        &amp;&amp;&amp;                               \hspace*{9mm}\
hts^s = {\rm\normalsize{ServerHandshakeTrafficSecret(...)}} \\
        &amp;&amp;&amp;                               \hspace*{9mm}\
hts^c = {\rm\normalsize{ClientHandshakeTrafficSecret(...)}} \\
        &amp; {server\_cert} &amp; {\larr} &amp;
{\rm\normalsize{X509Cert}}(n, \ s) \\
        &amp;&amp;&amp;                          \ \ \rm{where} \ n =
{\rm\normalsize{CH}}.server\_name, \\
        &amp;&amp;&amp;                          \ \ \hspace*{9mm} \ s
\in \{{\rm\normalsize{CH}}.s_{1}, ..., {\rm\normalsize{CH}}.s_{n}\}\\
    \rrbracket &amp; &amp; &amp; \\
    \end{array}}
\]</span></p>
<p><strong>ServerHello</strong> <img
src="./images/server_hello_layout.jpg" alt="server_hello_layout" /></p>
<p>Client receives the server hello message, computes handshake secrets,
and prepares for the traffic authentication sub-protocol. This is the
client state at the beginning of the authentication phase: <span
class="math display">\[
    {\begin{array}{llll}
    \llbracket &amp; &amp; &amp; \\
        &amp; {{handshake\_context}}       &amp; {\larr} &amp;
{\rm\normalsize{Concat}}(client\_hello\_msg, \\
        &amp;&amp;&amp;                                         \hspace*{12mm}
server\_hello\_msg) \\
        &amp; {{cipher\_suite\_id}} &amp; {\larr} &amp;
{\rm\normalsize{SH}}.cid, \\
        &amp; {{cipher\_suite}} &amp; {\larr} &amp;
{\rm\normalsize{CipherSuite}}({\rm\normalsize{SH}}.cid) \\
        &amp; {{traffic\_secrets}} &amp; {\larr} &amp; (hs, hts^s,
hts^c)  {\hspace*{60mm}} \\
        &amp;&amp;&amp;                               {\rm{where}} \ hs
\ \ \, = {\rm\normalsize{HandshakeSecret(...)}} \\
        &amp;&amp;&amp;                               \hspace*{9mm}\
hts^s = {\rm\normalsize{ServerHandshakeTrafficSecret(...)}} \\
        &amp;&amp;&amp;                               \hspace*{9mm}\
hts^c = {\rm\normalsize{ClientHandshakeTrafficSecret(...)}} \\
    \rrbracket &amp; &amp; &amp; \\
    \end{array}}
\]</span></p>
<p><span class="math display">\[
    {\begin{array}{l}
    (h^c, \, \{\tau_1,..,\tau_j\}, \, \{\kappa^c_{g_1},..,
\kappa^c_{g_n}\}) {\hspace*{2.6in}}
    \bot \\
    \\
    {\hspace*{2.5cm}}{\large{\xrightarrow {client\_hello(sn, \, \{
g_1,..,g_m \}, \, \{s_1,..,s_i\}, \,
    \{\tau_1,..,\tau_j\},
    \, \{k^c_{g_1},.., k^c_{g_m}\}, \, r_c)}}} \\
    \end{array}}
\]</span></p>
<p>Server processes <code>ClientHello</code>, checks if it can support
at least one DH group, validates the signature schemes indicated by the
client, and the ciphersuite indicated in <code>ClientHello</code>. If it
is satisfied, server selects the certificate, <span
class="math inline">\(\phi_s\)</span>, for the server name <span
class="math inline">\(sn\)</span> indicated in
<code>ClientHello</code>.</p>
<p><span class="math display">\[
    {\phi_s = sever\_cert(sn)}
\]</span></p>
<p>The server also chooses a ciphersuite, <span
class="math inline">\(\tau_i\)</span>:</p>
<p><span class="math display">\[
    {\tau \in \{ \tau_1,..,\tau_j\}}
\]</span></p>
<p>Next, server selects an elliptic curve group from the groups which
client supports: <span class="math inline">\(g_i \in  \{ g_1,..,g_m
\}\)</span>. It produces a fresh Diffie-Hellman key pair <span
class="math inline">\((\kappa^s_{g_i}, k^s_{g_i})\)</span> where <span
class="math inline">\(\kappa^s_{g_i}\)</span> is its private key (a
secret), and <span class="math inline">\(k^s_{g_i}\)</span> is the
public key. The secret is used to calculate DH shared secret, and the
latter is shared with the client.</p>
<p>Server performs its part of ECDHE using client’s key share and its
own private key, producing DH shared secret:</p>
<p><span class="math display">\[
    \rho = ecdhe(\kappa^s_{g_i}, \, k^c_{g_i})
\]</span></p>
<p>Using only <span class="math inline">\(\rho\)</span> as the key
material, server derives TLS handshake traffic secrets:</p>
<p><span class="math display">\[
    \chi = derive\_handshake\_traffic\_secrets(\rho)
\]</span></p>
<p>Now that the server has worked out cryptographic context, it prepares
it’s response, the <code>ServerHello</code> message. We name the
plaintext bytes constituting this message as <span
class="math inline">\(h_s\)</span> for short. It then creates an
environment initialized with these components:</p>
<p><span class="math display">\[
    {E^{auth}_{s} = (h^c\cdot h^s, \, \chi, \, \phi_s, \, \tau)}
\]</span></p>
<p>Finally, it outputs the message. Note that the ephemeral public key
component <span class="math inline">\(k^s_{g_i}\)</span> is part of the
<code>ServerHello</code> message.</p>
<p><span class="math display">\[
    {\begin{array}{l}
    (h^c, \, \{\kappa^c_{g_1},.., \kappa^c_{g_n}\}, \,
\{\tau_1,..,\tau_j\}) \hspace*{2.5in}
    (h^c\cdot h^s, \, \chi, \, \phi_s, \, \tau) \\
    \\
    {\hspace*{5cm}}{\large{\xleftarrow{server\_hello(g_i, \, \tau, \,
k^s_{g_i}, \, r_s) \\}}}
    \end{array}}
\]</span></p>
<p>Client processes<code>ServerHello</code>, checks that the group <span
class="math inline">\(g_i\)</span> selected by the server is one of the
groups it supports: <span class="math inline">\(g_i \in \{ g_1,..,g_m
\}\)</span>. Next, it runs ECDHE using server’s ephemeral public key,
<span class="math inline">\(k^s_{g_i}\)</span> and its own session
private key <span class="math inline">\(\kappa^c_{g_i}\)</span>,
producing the exact same DH shared secret:</p>
<p><span class="math display">\[
    { \rho = ecdhe(\kappa^c_{g_i}, \, k^s_{g_i}) }
\]</span></p>
<p>Using only <span class="math inline">\(\rho\)</span> as the key
material, client derives TLS handshake traffic secrets:</p>
<p><span class="math display">\[
    {\chi = derive\_handshake\_traffic\_secrets(\rho)}
\]</span></p>
<p>Thanks to some neat elliptic-curve math, the client ends up with the
exact same <span class="math inline">\(\rho\)</span> and <span
class="math inline">\(\chi\)</span> as the server. The <span
class="math inline">\(\chi\)</span> component is what the TLS spec calls
<code>server_handshake_traffic_secret</code>.</p>
<p>By the end of this message exchange, the client is equipped to
exchange encrypted and authenticated messages with the server.
Therefore, the client initializes its session with the message context,
session ciphersuite, and the traffic secrets:</p>
<p><span class="math display">\[
    { E^{auth}_c = (h^c\cdot h^s, \, \tau, \, \chi) }
\]</span></p>
<p>Note that the message context is merely a concatenation of
<em>plaintext slices</em> of ClientHello and ServerHello. The plaintext
slices start from the sixth byte (offset 5 in the zero-based index). The
first five bytes of ClientHello and ServerHello are data layer record
headers. This is clearly shown in the two diagrams below. Record layer
headers have a gray background while the plaintext fragments are shown
in the clear.</p>
<h4 id="encrypted-extensions">Encrypted Extensions</h4>
<p>As a part of handshake, the server is required to send the
EncryptedExtensions message immediately after the ServerHello message
(<a href="#xref-tls1.3-enc-ext">section 4.3.1, page 60 of TLS</a>). This
is the first encrypted message in the traffic. The server encrypted
using the key tucked in the <span class="math inline">\(\Chi\)</span>
component of the session</p>
<h3 id="authentication-phase">Authentication Phase</h3>
<p>In 1-RTT handshake, the server sends out the following three
messages: <code>Certificate</code>, <code>Certificate Verify</code>, and
<code>Finished</code>. These three messages constitute server
authentication, certificate signing key confirmation, and ensuring
handshake integrity, respectively. The client <em>has to processes</em>
these messages in the same sequence. Each message carries incremental
information necessary to verify the authenticity as well as the
integrity of the previous messages. We can summarize the information
contained in each of these messages, and the actions client is required
to carry out while processing these messages.</p>
<p>First, the <code>Certificate</code> message contains server’s
(non-empty) certificate chain. It is mandatory for servers to provide a
list of X.509 certificates. Recall that the <code>server_name</code>
extension in <code>ClientHello</code> identifies a server endpoint. The
first certificate in the chain represents the endpoint identified by
<code>server_name</code>. (Recall also that <code>sn</code> argument in
<a href="#xref-client-hello-spec">ClientHello</a> stands for
<code>server_name</code>). The first certificate in the list, therefore,
contains a public key to be used to verify the contents of the
immediately following <code>CertificateVerify</code> message.</p>
<p>Second, the <code>Certificate Verify</code></p>
<h3
id="protecting-confidentiality-integrity-and-authenticity-of-tls-traffic">Protecting
Confidentiality, Integrity, and Authenticity of TLS traffic</h3>
<p>Section 5.2, page 89 of RFC 8446 presents two type definitions for
protected data records. We reproduce the types here with minor
notational embellishments. For example, we indicate position of each
field relative to the beginning of the data structure. This comes handy
while writing constraints on field-lengths. They are also useful in
relating the sizes of the components of plaintext and ciphertext. We can
easily turn such specifications into assertions in the Rust program.</p>
<pre><code>    struct {
        0:1  - ContentType opaque_type = application_data;
            /* = 23 */
        1:2  - ProtocolVersion legacy_record_version = TLS_V1.2;
            /* = 0x0303 */
        3:2  - uint16 length;
            /* where 21 &lt; val &lt; 2^14+256; val aka CL */
        5:CL - opaque aead_ct_record[TLSCipherText.length];
            /* opaque[CL]*/
    } TLSCiphertext; /* thus, sizeof(TLSCiphertext) = 5+CL */</code></pre>
<p>To get a better picture, we will turn the above data definitions into
a horizontal layout, as a sequence of bytes, showing byte offsets of
different fields.</p>
<h3 id="tlsinnerplaintext">TlsInnerPlaintext</h3>
<p>This structure holds the plaintext which is to be protected. The
plaintext may be a handshake message fragment or raw bytes of the
application data. It holds handshake message in the authentication
phase, and subsequently, post-handshake, it holds application data
exchanged by the peers.</p>
<pre><code>    struct {
        0:PL     - opaque content[TLSPlaintext.length];
            /* opaque[PL] */
        PL:1     - ContentType type;
            /* = 22 if handshake; = 23 if application_data */
        PL+1:ZL  - uint8 zeroes[ZL];
            /* ZL == CL-(PL+1)-16 */
    } TLSInnerPlaintext;
    /* thus, sizeof(TLSInnerPlaintext) = IPL = PL+1+ZL = CL-16 */</code></pre>
<p>In the following discussion we will use PL to mean the size of
plaintext, in bytes. For brevity, we use CT for ContentType.</p>
<p>In TLSInnerPlaintext, the first field named <code>content</code>
holds the plaintext bytes. The size of this array is PL (bytes). TLS
does not allow zero length <code>content</code> field for handshake and
alert messages.</p>
<p>The next field <code>type</code> holds the content type of the
plaintext record. It denotes the <code>ContentType</code> of the message
in <code>content</code> field. CT will have different values depending
on the message or data being protected. Thus,</p>
<pre><code>        CT = 21 - an alert message,
        CT = 22 - one of the following handshake messages
                    - alert
                    - new_session_ticket
                    - encrypted_extensions
                    - certificate
                    - certificate_verify
                    - finished
        and
        CT = 23 - application specific data
            (i.e, HTTP request/response payload)</code></pre>
<p>TLS 1.3 allows encrypted records to be padded with zeroes as long as
the total size of TLSInnerPlaintext record doesn’t exceed 2^14 + 1
bytes. When the sender inflates the size of an encrypted record,
observers cannot tell the actual size of the plaintext. It is obvious
padding increases record size, and may adversely impact overall
performance.</p>
<p>Section 5.4 of RFC 8446 describes many aspects of record padding. In
our tests, we will see that most HTTP servers do not pad either
handshake records or application data records.</p>
<p>The following diagram shows the structure of TLSInnerPlaintext
without padding zeroes, which is the most common case.</p>
<pre><code>    0    1    2    3                            PL   PL+1
    +----+----+----+----/-*--*-/-+----+----+----+----+
    |  Handshake Message or Application Data    | CT |
    +----+----+----+----/-*--*-/-+----+----+----+----+
    &lt;------------------- Plaintext -----------------&gt;|
                        (PL bytes)

    |&lt;----------------------------------------------&gt;|
                    TlsInnerPlaintext
                      (PL+1 bytes)

            TlsInnerPlaintext without padding
</code></pre>
<p>TlsInnerPlaintext with arbitrary zero padding at the end of the data
block may be visualized thus:</p>
<pre><code>    0    1    2    3                           PL  PL+1              PL+1+ZL
    +----+----+----+---*---*---+----+----+----+----+--*-----*----*---+
    |  Handshake Message or Application Data  | CT |  Padding zeroes |
    +----+----+----+---*---*---+----+----+----+----+-*------*----*---+
    &lt;--------------- Plaintext --------------&gt;|    |&lt;- Optional Pad -&gt;
                    (PL bytes)                          (ZL bytes)

    |&lt;--------------------------------------------------------------&gt;|
                            TlsInnerPlaintext

            TlsInnerPlaintext with arbitrary-sized zero padding
</code></pre>
<h3 id="tlsciphertext">TlsCiphertext</h3>
<p>TLS 1.3 employs only Authenticated Encryption with Associated Data
(AEAD) ciphers. AEADs simultaneously protect confidentiality of the
plaintext, and the authenticity and integrity of ciphertext. In other
words, with the AEADs supported by TLS 1.3, one will not be able to
learn about the plaintext or the encryption key even if one has access
to all ciphertexts exchanged by the peers. At the same time, AEAD
ciphers will be able to detect if either ciphertext or the MAC has been
tampered or altered in transit. Practical AEADs combine a secure cipher
with a strong MAC. Their composition has been proved to provide highest
levels of security.</p>
<p>TLS 1.3 defines 5 AEAD algorithms for record protection:</p>
<pre><code>    AES_128_GCM         - MUST implement this AEAD algorithm.
    AES_256_GCM         - SHOULD implement this AEAD algorithm.
    CHACHA20_POLY1305   - SHOULD implement this AEAD algorithm.
    AES_128_CCM
    AES_256_CCM</code></pre>
<p>In <code>tlsc</code>, we support the first three algorithms from this
list which includes the mandatory AES_128_GCM.</p>
<pre><code>
    0    1    2    3    4    5    6                    5+IPL      5+CL
    +----+----+----+----+----+----+----+--*--*----+----|---*--*-+----+
    | 23 | 0x0303  |    CL   |     Encrypted Data      |     MAC     |
    +----+----+----+----+----+----+----+--*--*----+----+---*--*-+----+
    &lt;--- Additional Data ---&gt;|&lt;-- TlsInnerPlainText --&gt;|&lt;- AEAD Tag -&gt;

    |&lt;----------------------&gt;|&lt;-------------------------------------&gt;|
            AAD                            AEAD output
         (5 bytes)                         (CL bytes)
         plaintext                         ciphertext
</code></pre>
<h3 id="key-derivation">Key Derivation</h3>
<p>The server processes the ClientHello message and determines the
ciphersuite for the session. The server responds with the ServerHello
message which includes its <em>key share</em>, which is server’s
ephemeral Diffie-Hellman share. In <code>tlsc</code>, ClientHello
contains two shares, each in an EC group: X25519 and secp256r1. These
are the only two <code>supported_groups</code> in <code>tlsc</code>.</p>
<figure>
<img src="./images/key_schedule.jpg" alt="key_schedule" />
<figcaption aria-hidden="true">key_schedule</figcaption>
</figure>
<h2 id="references">References</h2>
<p><a id="xref-tls1.3-enc-ext"></a> The Transport Layer Security (TLS)
Protocol Version 1.3.
https://www.rfc-editor.org/rfc/rfc8446.html#section-4.3.1</p>
</body>
</html>
